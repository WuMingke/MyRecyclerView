协程与线程的区别
• 线程是操作系统调度的基本单位，一个进程可以拥有多个线程，每个线程独立运行，但它们共享进程的资源。
线程切换的开销较大，且线程间的通信需要通过共享内存或消息传递等方式实现，容易出现资源竞争、死锁等问题。

• 协程是用户空间下的轻量级线程，也称为“微线程”。它不依赖操作系统的调度，而是由用户自己控制协程的执行。
协程之间的切换只需要保存和恢复少量的状态，开销较小。协程通信和数据共享的方式比线程更加灵活，
通常使用消息传递或共享状态的方式实现。

suspend fun xx() -> Object xx(Continuation c)
kotlin编译器 会对带有 suspend 的方法在最终的字节码生成上进行额外更改，这个过程又被称作 CPS转换
协程通过 CPS 转换来实现异步编程
CPS（Continuation Passing Style）转换是一种将函数转换为回调函数的编程技术。-》将程序接下来要执行的代码进行传递的一种模式
在 CPS 转换中，一个函数不会像通常那样直接返回结果，而是接受一个额外的回调函数作为参数，
用于接收函数的结果。这个回调函数本身也可能接受一个回调函数，形成一个连续的回调链。
这种方式可以避免阻塞线程，提高代码的并发性能。

CPS 转换过程中，函数签名的细节
 suspend 修饰的函数就是挂起函数
 挂起函数，在执行的时候并不一定都会挂起
 挂起函数只能在其他挂起函数中被调用
 挂起函数里包含其他挂起函数的时候，它才会真正被挂起

Continuation 可以理解为一个CallBack，负责保存函数的执行状态，挂起、恢复的操作
suspend 的本质，就是 CallBack。

看编译后的字节码，
从ContinuationImpl开始  相当于用一个新的 Continuation 包装了旧的 Continuation
ContinuationImpl 有两个局部变量，
        Object result; 协程返回结果
            int label; 表示协程状态机当前的状态
每次协程切换后，都会检查是否发生异常
continuation 在整个运行期间，只会产生一个实例，这能极大的节省内存开销(对比 CallBack)

对于 lambda 函数，在编译后会生成一个实现 Function 接口的类，并在使用 lambda 函数时创建一个单例对象来调用，创建对象的过程是编译器自动生成的代码

继承关系
- Continuation: 续体，恢复协程的执行
    - BaseContinuationImpl: 实现 resumeWith(Result) 方法，控制状态机的执行，定义了 invokeSuspend 抽象方法
        - ContinuationImpl: 增加 intercepted 拦截器，实现线程调度等
            - SuspendLambda: 封装协程体代码块
                - 协程体代码块生成的子类: 实现 invokeSuspend 方法，其内实现状态机流转逻辑

协程的 挂起和恢复 有两个关键方法: invokeSuspend() 和 resumeWith(Result)。
invokeSuspend() 方法是对协程代码块的封装，内部加入状态机机制将整个逻辑分为多块，分隔点就是每个挂起点。
协程启动时会先调用一次 invokeSuspend() 函数触发协程体的开始执行，后面每当调用到一个挂起函数时，
挂起函数会返回 COROUTINE_SUSPENDED 标识，从而 return 停掉 invokeSuspend() 函数的执行，即非阻塞挂起。
编译器会为挂起函数自动添加一个 continuation 续体对象参数，表示调用它的那个协程代码块，在该挂起函数执行完成后，
就会调用到续体 continuation.resumeWith() 方法来返回结果(或异常)，而在 resumeWith() 中又调用了 invokeSuspend() 方法，
其内根据状态机的状态来恢复协程的执行。这就是整个协程的挂起和恢复过程。




为什么还要增一个 Object 类型返回值呢？
    用于确定，该挂起函数是否真的被挂起

为什么返回值类型是Object？
    对于挂起函数而言，返回值有可能是 COROUTINE_SUSPENDED、Unit.INSTANCE
    或者最终返回我们方法需要的返回类型结果，所以采用 Object 作为返回值以适应所有结果

这里为什么要再去创建一个 Continuation？不是在runBlocking()里已经利用lambda表达式实例化了函数对象了吗？

/******/
不知道是否会有同学有这个疑问，所以这里依然需要解释一遍。

我们知道，在 kotlin 中，lambda 是匿名内部类的一种实例化方式(简化)，所以这里只是给 runBlocking() 函数传递了所需要的方法参数。但是这个 lambda 内部的 invoke() 依然是挂起函数(因为增加过suspend)，所以这里的匿名内部类实际上也是实现了 Continuation(默认的只有Funcation1,2,3等等),为了便于底层调用 invoke() 时传递 Continuation ，否则后续挂起恢复流程就断了。相应的，为了延续 invoke() 里的挂起函数流程，编译器在当前匿名类内部又创建了一个 **anonymous constructor(无类型) ** 的内部类(实际上是继承自SuspendLambda)，从而在其 ivokeSuspend() 里执行当前挂起函数的状态机。

所以来说，大家可以理解我们传递的 lambda 相当于一个入口，但是其内部(即invoke)的触发方法，又是一个 挂起函数 ，这也就是为什么 invoke() 里需要创建 Continuation ，以及为什么 invoke() 方法参数里需要有 continuation 的原因，以及为什么字节码中会出现 new Function2((Continuation) null) ,Continuation 为null 的情况，因为它压根没有 continuation 啊(不在挂起函数内部)。

这里的解释稍许有些啰嗦，但这对于理解全流程将非常有用，如果不是很理解，建议多读几遍。
/******/


协程的同步：
    1 synchronized
    2 Mutex(互斥锁) 推荐的
    从原理上而言，Mutex 是通过 一个 AtomicInteger 类型的状态记录锁的状态(是否被占用)，并使用一个 ConcurrentLinkedQueue 类型的队列来持有 等待持有锁 的协程，从而解决多个协程并发下的同步问题。

    相比传统的 synchronized 阻塞线程，Mutex 内部使用了 CAS机制，并且支持协程的挂起恢复，其可扩展性，其都更具有优势；并且在协程的挂起函数中使用 synchronized，也可能会影响协程的正常调度和执行。故无论是上手难度及可读性，Mutex 无疑是更适合协程开发者的。

为什么 Mutex 的性能其实不如 synchronized 呢？
Mutex 在处理并发访问时会产生额外的开销，由于 Mutex 是一个互斥锁，它需要操作系统层面的支持来实现，包括支持挂起和恢复、上下文切换和内核态和用户态之间的切换等操作，这些操作都需要较大的系统开销和时间，导致 Mutex 的性能较差。

而 synchronized 采用了一种更加灵活的方式来实现锁的机制，它会检查锁状态，如果没有被持有，则可以立即获取锁。如果锁被持有，则选择等待，或者继续执行其他的任务。从具体的实现上来说，synchronized 底层由jvm保证，在运行过程中，可能会出现偏向锁、轻量级锁、重量级锁等。
当我们在选用 Kotlin 协程的时候，就已经选择了为了使用方便去容忍牺牲一部分性能。再者说，如果你的业务真的对性能要求极致，那么协程本身其实并不是首选推荐的，此时你应该选用线程池去处理，从而得到性能的最大化，因为协程本身的微型机制就需要做更多的额外操作。

Mutex 是协程中的推荐解决同步问题的方式，而且支持挂起与恢复，这点是其他同步解决方式无法具备的；再者说，Mutex 的上手难度相比 synchronized 低了不少。而至于性能上的差距，对于我们的业务开发而言，几乎是不会感知到，所以在协程中，Kotlin团队建议我们使用Mutex。

Flow在解决同步问题的时候，用的 synchronized

从底层实现来看：

kotlin协程基于 java线程模型 ，故底层依然是使用了 线程池 作为任务承载，但相比传统的线程模型，协程在其基础上搭建了一套基于语言级别的 ”微型“ 线程模型。并定义了挂起函数作为相应的子任务，其内部采用了状态机的思想，用于实现协程中的挂起与恢复。

在挂起与恢复的实现上，使用了 suspend 关键字标记的函数被称为挂起函数。其在字节码中，会经过 CPS转换 为一个带有 Continuation 参数，返回值为 Object 的方法。而 Continuation 正是用于保存我们的函数状态、步骤，从而实现挂起恢复，其内部也都包含着上一个 Continuation，正如 callback 的嵌套一样。

当我们的函数被挂起时，我们当前的函数内部会实例化一个 ContinuationImpl() ，其内部 invokeSuspend() 又维护着当前的函数逻辑，并使用一个 label 作为状态进行流转，如果我们的函数内部依然有其他挂起函数，此时也会将当前的 Continuation 对象传入子挂起函数内部，从而实现 Continuation 的传递，并更改当前的函数状态。而当我们最底层的方法执行结束后，此时就会再次触发父 ContinuationImpl 内部的 invokeSuspend() 方法，从而回到调用方的逻辑内部，从而完成挂起函数的恢复。以此类推，直到我们最开始的调用方法内；
从性能上去看：


协程的性能并不优于线程池或者其他异步框架，主要是其做了更多语言级别步骤，但通常情况下，与其他框架的性能几乎一致，因为相比IO的耗时，语言级别的损耗可以几乎忽略不计。

从设计模式去看：


协程使得开发者可以自行管理异步任务，而不同于线程的抢占式任务，并且写成还支持子协程的嵌套关闭、更简便的异常处理机制等，故相比其他异步框架，协程的理念更加先进。


异常：
    如果是 launch 启动的子协程，是需要 CoroutineExceptionHandler 配合处理的，如果是 async 启动的协程，就是真的不抛，等到 Deferred.await 时再抛。


